<!DOCTYPE html>
<html>
<head>
    <title>Instagram Webhook Test</title>
    <script src="mock-data.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            background-color: #f9f9f9;
        }
        button {
            background-color: #E1306C;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #c13066;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            margin: 10px 0;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <h1>Instagram Webhook Test</h1>
    
    <div>
        <h2>Send Restaurant Recommendation</h2>
        <textarea id="message-text">I tried this amazing new spot called Taco Deluxe in San Diego last week. Their fish tacos are incredible, and they have the best margaritas!</textarea>
        <br>
        <button id="send-button">Simulate Instagram Message</button>
        <div id="webhook-status"></div>
    </div>
    
    <div class="card" id="mock-results" style="display: none;">
        <h2>Mock Processing Results</h2>
        <div id="processing-results"></div>
    </div>
    
    <div class="card">
        <h2>Latest Restaurant Added</h2>
        <div id="restaurant-info"></div>
    </div>

    <script>
        // Display the first restaurant (newest) from mock data
        function displayLatestRestaurant() {
            const latestRestaurant = restaurantsMock.restaurants[0];
            
            if (latestRestaurant) {
                document.getElementById('restaurant-info').innerHTML = `
                    <h3>${latestRestaurant.name}</h3>
                    <p><strong>Location:</strong> ${latestRestaurant.location}</p>
                    <p><strong>Cuisine:</strong> ${latestRestaurant.cuisine.join(', ')}</p>
                    <p><strong>Rating:</strong> ${latestRestaurant.rating || 'N/A'}</p>
                    <p><strong>Price Range:</strong> ${latestRestaurant.priceRange}</p>
                    <p><strong>Status:</strong> ${latestRestaurant.visitStatus}</p>
                    <p><strong>Original Message:</strong> "${latestRestaurant.originalMessage}"</p>
                `;
            } else {
                document.getElementById('restaurant-info').innerHTML = "<p>No restaurants found!</p>";
            }
        }

        // Function to check if a message appears to be a restaurant recommendation
        function isRestaurantRecommendation(messageText) {
            const restaurantKeywords = [
                'restaurant', 'café', 'cafe', 'bistro', 'diner', 'eatery', 'food', 'eat',
                'dining', 'cuisine', 'meal', 'lunch', 'dinner', 'breakfast', 'brunch',
                'delicious', 'tasty', 'yummy', 'tried', 'visited', 'recommend'
            ];
            
            const lowercaseMessage = messageText.toLowerCase();
            
            return restaurantKeywords.some(keyword => lowercaseMessage.includes(keyword));
        }

        // Extract a restaurant name from text
        function extractRestaurantName(message) {
            // Look for patterns like "restaurant called X" or "X restaurant"
            const nameMatch = message.match(/restaurant (?:called|named) ([\w\s'&]+)|([\w\s'&]+) restaurant/i);
            if (nameMatch) {
                return (nameMatch[1] || nameMatch[2]).trim();
            }
            
            // Look for patterns like "place called X" or "spot called X"
            const placeMatch = message.match(/(?:place|spot|joint|eatery) (?:called|named) ([\w\s'&]+)/i);
            if (placeMatch) {
                return placeMatch[1].trim();
            }
            
            // If no explicit pattern is found, try to find capitalized words
            const words = message.split(/\s+/);
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                // Check if word starts with capital letter and is not at the beginning of a sentence
                if (i > 0 && word.length > 2 && word[0] === word[0].toUpperCase() && word[0] !== word[0].toLowerCase() && !isCommonWord(word)) {
                    return word;
                }
            }
            
            return "Unknown Restaurant";
        }

        // Check if a word is common (not likely to be a restaurant name)
        function isCommonWord(word) {
            const commonWords = ['the', 'and', 'but', 'for', 'nor', 'yet', 'so', 'as', 'at', 'by', 'in', 'of', 'on', 'to', 'up', 'it', 'is', 'are', 'was', 'were', 'this', 'that', 'they', 'their'];
            return commonWords.includes(word.toLowerCase());
        }

        // Extract location from text
        function extractLocation(message) {
            // Look for patterns like "in X" or "at X" or "located in X"
            const locationMatch = message.match(/(?:in|at|located in) ([\w\s,]+)(?:\.|\s|$)/i);
            return locationMatch ? locationMatch[1].trim() : "Unknown Location";
        }

        // Extract cuisine types from text
        function extractCuisineTypes(message) {
            const cuisineTypes = [
                'Italian', 'Mexican', 'Chinese', 'Japanese', 'Indian', 'Thai', 'French', 
                'Mediterranean', 'American', 'Korean', 'Vietnamese', 'Greek', 'Spanish', 
                'Turkish', 'Lebanese', 'Brazilian', 'Peruvian'
            ];
            
            const foundCuisines = [];
            cuisineTypes.forEach(cuisine => {
                if (message.toLowerCase().includes(cuisine.toLowerCase())) {
                    foundCuisines.push(cuisine);
                }
            });
            
            return foundCuisines.length > 0 ? foundCuisines : ['Unknown'];
        }

        // Simulate processing a restaurant recommendation
        function processRestaurantRecommendation(message) {
            const isRecommendation = isRestaurantRecommendation(message);
            
            if (!isRecommendation) {
                return {
                    success: false,
                    message: "This doesn't appear to be a restaurant recommendation."
                };
            }
            
            // Extract restaurant info
            const name = extractRestaurantName(message);
            const location = extractLocation(message);
            const cuisine = extractCuisineTypes(message);
            
            // Create a new restaurant entry
            const newRestaurant = {
                _id: "rest_" + Math.floor(Math.random() * 10000),
                name: name,
                location: location,
                cuisine: cuisine,
                priceRange: "$$$",
                originalMessage: message,
                visitStatus: "want_to_visit",
                createdAt: new Date().toISOString(),
                source: "instagram"
            };
            
            // Add to mock data
            restaurantsMock.restaurants.unshift(newRestaurant);
            restaurantsMock.pagination.total++;
            
            // Update stats
            statsMock.totalRecommendations++;
            statsMock.visitStatusStats.want_to_visit++;
            
            // Update top cuisines if applicable
            const cuisineIndex = statsMock.topCuisines.findIndex(c => c._id === cuisine[0]);
            if (cuisineIndex >= 0) {
                statsMock.topCuisines[cuisineIndex].count++;
                // Re-sort cuisines
                statsMock.topCuisines.sort((a, b) => b.count - a.count);
            }
            
            // Update recent activity
            statsMock.recentActivity.unshift({
                _id: newRestaurant._id,
                name: newRestaurant.name,
                createdAt: newRestaurant.createdAt,
                visitStatus: newRestaurant.visitStatus
            });
            
            // Keep only top 4 recent activities
            if (statsMock.recentActivity.length > 4) {
                statsMock.recentActivity.pop();
            }
            
            return {
                success: true,
                restaurant: newRestaurant
            };
        }

        // When the page loads, display the latest restaurant
        window.onload = function() {
            displayLatestRestaurant();
            
            // Set up event listener for the send button
            document.getElementById('send-button').addEventListener('click', function() {
                const messageText = document.getElementById('message-text').value;
                const statusEl = document.getElementById('webhook-status');
                const resultsEl = document.getElementById('processing-results');
                
                // Process the message
                const result = processRestaurantRecommendation(messageText);
                
                if (result.success) {
                    statusEl.innerHTML = `
                        <div class="status success">
                            <p>✅ Message processed successfully! Restaurant "${result.restaurant.name}" has been saved.</p>
                        </div>
                    `;
                    
                    resultsEl.innerHTML = `
                        <p><strong>Extracted Name:</strong> ${result.restaurant.name}</p>
                        <p><strong>Extracted Location:</strong> ${result.restaurant.location}</p>
                        <p><strong>Identified Cuisine:</strong> ${result.restaurant.cuisine.join(', ')}</p>
                        <p><strong>Original Message:</strong> "${messageText}"</p>
                    `;
                    
                    document.getElementById('mock-results').style.display = 'block';
                    
                    // Update the displayed restaurant
                    displayLatestRestaurant();
                } else {
                    statusEl.innerHTML = `
                        <div class="status error">
                            <p>❌ ${result.message}</p>
                        </div>
                    `;
                    document.getElementById('mock-results').style.display = 'none';
                }
            });
        };
    </script>
</body>
</html> 