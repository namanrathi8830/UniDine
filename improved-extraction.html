<!DOCTYPE html>
<html>
<head>
    <title>Improved Restaurant Extraction</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            background-color: #f9f9f9;
        }
        button {
            background-color: #E1306C;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            margin: 10px 0;
        }
        .success { color: green; }
        .error { color: red; }
        pre { 
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>Improved Restaurant Extraction</h1>
    
    <div>
        <h2>Test Message</h2>
        <textarea id="message-text">I went to this amazing restaurant called Sushi Spot in Tokyo last week. The sashimi was incredibly fresh and the service was impeccable. Definitely try their omakase if you visit Japan!</textarea>
        <br>
        <button id="test-button">Test Extraction</button>
        <p>Common test cases:</p>
        <button class="test-case" data-message="I went to this amazing restaurant called Sushi Spot in Tokyo last week. The sashimi was incredibly fresh and the service was impeccable. Definitely try their omakase if you visit Japan!">Test 1: Explicit Name</button>
        <button class="test-case" data-message="You have to check out Burger Barn when you're in Chicago. Their double bacon cheeseburger is to die for and they have the best milkshakes!">Test 2: Implicit Name</button>
        <button class="test-case" data-message="I had an incredible meal yesterday. The place in Manhattan has the most amazing pasta I've ever tried. The chef is Italian and uses authentic recipes.">Test 3: Ambiguous</button>
        <button class="test-case" data-message="I couldn't decide between Taco Palace in San Diego and Burger Heaven in Los Angeles, but ended up at Taco Palace and it was fantastic!">Test 4: Multiple Restaurants</button>
        <button class="test-case" data-message="Hey there! Just checking in to see how you're doing. Hope you had a great weekend!">Test 5: Not a Restaurant</button>
    </div>
    
    <div class="card" id="results" style="display: none;">
        <h2>Results</h2>
        <div id="results-content"></div>
    </div>

    <script>
        // Improved version of isRestaurantRecommendation
        function isRestaurantRecommendation(messageText) {
            // Score-based approach instead of binary
            let score = 0;
            const message = messageText.toLowerCase();
            
            // Restaurant/dining explicit references (high value)
            const restaurantExplicit = [
                'restaurant', 'cafe', 'café', 'bistro', 'eatery', 'diner', 
                'pizzeria', 'steakhouse', 'bakery', 'trattoria', 'house', 'grill',
                'pub', 'tavern', 'bar', 'joint', 'kitchen', 'garden'
            ];
            
            // Food references (medium value)
            const foodWords = [
                'food', 'meal', 'dinner', 'lunch', 'breakfast', 'brunch', 'dish',
                'menu', 'cuisine', 'pizza', 'burger', 'sushi', 'pasta', 'taco',
                'alfredo', 'curry', 'noodle', 'steak', 'salad', 'bread', 'sandwich'
            ];
            
            // Dining experience words (lower value)
            const diningWords = [
                'eat', 'ate', 'dining', 'delicious', 'tasty', 'yummy', 
                'tried', 'visited', 'recommend', 'chef', 'waiter', 'service',
                'ordered', 'tasted', 'enjoyed', 'amazing', 'excellent', 'had'
            ];
            
            // Check for explicit restaurant patterns (highest value)
            if (
                message.match(/restaurant (?:called|named) \w+/i) || 
                message.match(/(?:place|spot|joint) (?:called|named) \w+/i) ||
                message.match(/\w+ (?:restaurant|cafe|café|bistro)/i)
            ) {
                score += 25; // Strong indicator
            }
            
            // Check for capitalized restaurant-like names
            const capitalizedPlacePattern = /([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)(?:\s+(?:in|at|near))/;
            const placeMatch = messageText.match(capitalizedPlacePattern);
            if (placeMatch && placeMatch[1] && !isLikelyLocation(placeMatch[1])) {
                score += 20; // Strong indicator of a place name followed by location
            }
            
            // Check for explicit restaurant words
            for (const word of restaurantExplicit) {
                if (message.includes(word)) {
                    score += 15;
                    break; // Only count once
                }
            }
            
            // Check for food words
            for (const word of foodWords) {
                if (message.includes(word)) {
                    score += 5;
                }
            }
            
            // Check for dining experience words
            for (const word of diningWords) {
                if (message.includes(word)) {
                    score += 3;
                }
            }
            
            // Check for phrases that indicate recommendations
            if (
                message.includes('you should try') || 
                message.includes('you have to') || 
                message.includes('worth visiting') ||
                message.includes('i recommend') ||
                message.includes('check out')
            ) {
                score += 10;
            }
            
            // Detect capitalized words that could be restaurant names
            const capitalizedWords = messageText.match(/[A-Z][a-z]+ [A-Z][a-z]+/g);
            if (capitalizedWords && capitalizedWords.length > 0) {
                score += 8;
            }
            
            // Check for food+location pattern (e.g., "had pasta in Bengaluru")
            if ((message.includes('had') || message.includes('ate') || message.includes('tried')) && 
                (message.match(/\bin\s+[A-Z][a-z]+/i) || message.match(/\bat\s+[A-Z][a-z]+/i))) {
                score += 12; // Moderate indicator
            }
            
            // Anti-patterns (messages that likely aren't food-related)
            if (
                (message.includes('just checking in') && !message.includes('restaurant') && !message.includes('food') && !message.includes('eat')) ||
                (message.includes('how are you') && !message.includes('restaurant') && !message.includes('food')) ||
                (message.includes('let me know') && !message.includes('restaurant') && !message.includes('food')) ||
                (message.length < 30 && !message.includes('restaurant') && !message.includes('food') && !message.includes('ate'))
            ) {
                score -= 15;
            }
            
            // Return confidence level (threshold is 10)
            const confidence = score >= 20 ? 'high' : score >= 10 ? 'medium' : 'low';
            return {
                isRecommendation: score >= 10,
                score: score,
                confidence: confidence
            };
        }

        // Improved restaurant name extraction
        function extractRestaurantName(message) {
            // Candidates with confidence scores
            let candidates = [];
            
            // Look for patterns like "restaurant called X" or "X restaurant" (highest confidence)
            const explicitPatterns = [
                {regex: /restaurant (?:called|named) ([\w\s'&\-]+?)(?:\.|,|\s\w+\s|$)/i, confidence: 0.9},
                {regex: /([\w\s'&\-]+) restaurant/i, confidence: 0.85},
                {regex: /(?:place|spot|joint|eatery|cafe|café|diner) (?:called|named) ([\w\s'&\-]+?)(?:\.|,|\s\w+\s|$)/i, confidence: 0.8},
                {regex: /try (?:the |an? )?([\w\s'&\-]+?)(?:\sin|\sat|\.|\s?$)/i, confidence: 0.6},
                {regex: /(?:at|to) (?:the |an? )?([\w\s'&\-]+?)(?:\sin|\.|,|\s\w+\s|$)/i, confidence: 0.5}
            ];
            
            // Check for explicit mentions
            for (const pattern of explicitPatterns) {
                const match = message.match(pattern.regex);
                if (match && match[1]) {
                    // Clean up the name
                    let name = match[1].trim();
                    // Don't allow very short names unless they're explicitly identified
                    if (name.length > 2 || pattern.confidence > 0.7) {
                        candidates.push({name, confidence: pattern.confidence});
                    }
                }
            }
            
            // Look for capitalized place names followed by location indicators
            const placeLocationPattern = /([A-Z][a-z'&\-]+(?:\s[A-Z][a-z'&\-]+)*)\s+in\s+([A-Z][a-z'&\-]+(?:\s[A-Z][a-z'&\-]+)*)/g;
            let match;
            while ((match = placeLocationPattern.exec(message)) !== null) {
                const name = match[1].trim();
                const location = match[2].trim();
                
                // Skip if the "name" is a common verb or pronoun
                const commonVerbs = ["Went", "Had", "Visited", "Tried", "Ate", "Got", "Ordered"];
                if (!commonVerbs.includes(name) && !isCommonPhrase(name) && !isCommonWord(name)) {
                    candidates.push({name, confidence: 0.85, location});
                }
            }
            
            // Look for capitalized words that might be restaurant names
            const capitalizedPattern = /(?:^|[.!?]\s+|\n)([A-Z][a-z]+(?: [A-Z][a-z]+)+)/g;
            while ((match = capitalizedPattern.exec(message)) !== null) {
                const name = match[1].trim();
                
                // Skip if it's likely a city/country name
                const locationMatches = [
                    "New York", "Los Angeles", "San Francisco", "San Diego", 
                    "Las Vegas", "Hong Kong", "United States", "North America",
                    "Bengaluru", "Mumbai", "Delhi", "Chennai"
                ];
                
                if (!locationMatches.includes(name) && !isCommonPhrase(name)) {
                    candidates.push({name, confidence: 0.7});
                }
            }
            
            // Look for quotes around names
            const quotePattern = /"([^"]+)"/g;
            while ((match = quotePattern.exec(message)) !== null) {
                candidates.push({name: match[1].trim(), confidence: 0.6});
            }
            
            // Advanced - look for capitalized compound names with "House", "Grill", etc.
            const compoundNamePattern = /([A-Z][a-z'&\-]+(?:\s+[A-Z][a-z'&\-]+)*\s+(?:House|Grill|Kitchen|Restaurant|Cafe|Bistro|Bar|Pub|Tavern))/g;
            while ((match = compoundNamePattern.exec(message)) !== null) {
                candidates.push({name: match[1].trim(), confidence: 0.9});
            }
            
            // Advanced - look for capitalized words after certain verbs
            const verbPattern = /(?:visited|tried|ate at|went to|at|to)(?: the| an?)? ([A-Z][a-z'&\-]+(?:\s[A-Z][a-z'&\-]+)*)/i;
            const verbMatch = message.match(verbPattern);
            if (verbMatch && verbMatch[1]) {
                candidates.push({name: verbMatch[1].trim(), confidence: 0.5});
            }
            
            // Advanced - look for "visiting" pattern which often indicates a place
            const visitingPattern = /visiting ([A-Z][a-z'&\-]+(?:\s[A-Z][a-z'&\-]+)*)/i;
            const visitMatch = message.match(visitingPattern);
            if (visitMatch && visitMatch[1]) {
                const potentialName = visitMatch[1].trim();
                if (!isLikelyLocation(potentialName)) {
                    candidates.push({name: potentialName, confidence: 0.8});
                }
            }
            
            // Look for names where someone "had" a specific dish
            // This is a special case for mixed casual messages
            const hadDishPattern = /(?:visiting|at) ([A-Z][a-z'&\-]+(?:\s[A-Z][a-z'&\-]+)*) (?:where|wherein|and|when)? (?:i|we|they) had/i;
            const hadDishMatch = message.match(hadDishPattern);
            if (hadDishMatch && hadDishMatch[1]) {
                const potentialName = hadDishMatch[1].trim();
                if (!isLikelyLocation(potentialName)) {
                    candidates.push({name: potentialName, confidence: 0.85});
                }
            }
            
            // Sort by confidence and return the best candidate
            candidates.sort((a, b) => b.confidence - a.confidence);
            
            if (candidates.length > 0) {
                // Filter out common words and false positives
                const validCandidates = candidates.filter(c => 
                    c.name.length > 2 && 
                    !isCommonPhrase(c.name) && 
                    !isLikelyLocation(c.name));
                
                if (validCandidates.length > 0) {
                    return {
                        name: validCandidates[0].name,
                        confidence: validCandidates[0].confidence,
                        allCandidates: validCandidates.map(c => `${c.name} (${c.confidence.toFixed(2)})`)
                    };
                }
            }
            
            return {
                name: "Unknown Restaurant",
                confidence: 0,
                allCandidates: candidates.map(c => `${c.name} (${c.confidence.toFixed(2)})`)
            };
        }

        // Improved location extraction
        function extractLocation(message) {
            // Known location patterns with confidence scores
            const locationPatterns = [
                // "in X" patterns
                {regex: /(?:^|\W)in ([A-Z][a-z]+(?:\s[A-Z][a-z]+){0,2})(?:\.|\s|$)/g, confidence: 0.8},
                
                // "at X" patterns
                {regex: /(?:^|\W)at ([A-Z][a-z]+(?:\s[A-Z][a-z]+){0,2})(?:\.|\s|$)/g, confidence: 0.7},
                
                // "located in X" patterns
                {regex: /located (?:in|at) ([A-Z][a-z]+(?:\s[A-Z][a-z]+){0,2})(?:\.|\s|$)/g, confidence: 0.9},
                
                // "visiting X" or "visited X" patterns
                {regex: /visit(?:ing|ed) [^A-Z]* ([A-Z][a-z]+(?:\s[A-Z][a-z]+){0,2})(?:\.|\s|$)/g, confidence: 0.6}
            ];
            
            let candidates = [];
            
            // Check for explicit locations using patterns
            for (const pattern of locationPatterns) {
                let match;
                while ((match = pattern.regex.exec(message)) !== null) {
                    // Clean up the location
                    let location = match[1].trim();
                    
                    // Only consider locations that are likely to be places
                    if (isLikelyLocation(location)) {
                        candidates.push({location, confidence: pattern.confidence});
                    }
                }
            }
            
            // Special case - check for "X wherein" pattern which often indicates a location
            const whereinPattern = /([A-Z][a-z]+(?:\s[A-Z][a-z]+){0,2}) wherein/i;
            const whereinMatch = message.match(whereinPattern);
            if (whereinMatch && whereinMatch[1]) {
                const location = whereinMatch[1].trim();
                if (isLikelyLocation(location)) {
                    candidates.push({location, confidence: 0.85});
                }
            }
            
            // Check for common city/state/country names
            const commonLocations = [
                "New York", "Los Angeles", "Chicago", "San Francisco", "San Diego", 
                "Miami", "Seattle", "Boston", "Washington", "Dallas", "Houston",
                "Tokyo", "Paris", "London", "Rome", "Berlin", "Madrid", "Bangkok",
                "Beijing", "Hong Kong", "Manhattan", "Brooklyn", "Queens", "Bronx",
                "Bengaluru", "Mumbai", "Delhi", "Chennai", "Hyderabad", "Kolkata",
                "Singapore", "Dubai", "Abu Dhabi", "Toronto", "Vancouver", "Sydney"
            ];
            
            for (const loc of commonLocations) {
                if (message.includes(loc)) {
                    candidates.push({location: loc, confidence: 0.85});
                }
            }
            
            // Sort by confidence
            candidates.sort((a, b) => b.confidence - a.confidence);
            
            if (candidates.length > 0) {
                return {
                    location: candidates[0].location,
                    confidence: candidates[0].confidence,
                    allCandidates: candidates.map(c => `${c.location} (${c.confidence.toFixed(2)})`)
                };
            }
            
            return {
                location: "Unknown Location",
                confidence: 0,
                allCandidates: []
            };
        }

        // Improved cuisine extraction
        function extractCuisineTypes(message) {
            const cuisineTypes = {
                "Italian": ["italian", "pasta", "pizza", "risotto", "carbonara", "tiramisu", "alfredo"],
                "Mexican": ["mexican", "taco", "burrito", "quesadilla", "enchilada", "guacamole"],
                "Chinese": ["chinese", "dim sum", "dumpling", "kung pao", "szechuan", "wonton"],
                "Japanese": ["japanese", "sushi", "sashimi", "ramen", "tempura", "omakase", "teriyaki"],
                "Indian": ["indian", "curry", "tikka", "masala", "naan", "tandoori"],
                "Thai": ["thai", "pad thai", "curry", "tom yum"],
                "French": ["french", "croissant", "baguette", "escargot", "coq au vin"],
                "Mediterranean": ["mediterranean", "hummus", "falafel", "kebab"],
                "American": ["american", "burger", "fries", "sandwich", "bbq", "milkshake"],
                "Korean": ["korean", "kimchi", "bibimbap", "bulgogi"],
                "Vietnamese": ["vietnamese", "pho", "banh mi"],
                "Greek": ["greek", "gyro", "souvlaki", "moussaka"],
                "Spanish": ["spanish", "paella", "tapas"],
                "Turkish": ["turkish", "kebab", "baklava"],
                "Lebanese": ["lebanese", "falafel", "tabouleh"],
                "Brazilian": ["brazilian", "churrasco"],
                "Peruvian": ["peruvian", "ceviche"]
            };
            
            // Also look for specific dishes mentioned
            const dishToCuisine = {
                "alfredo pasta": "Italian",
                "spaghetti": "Italian",
                "pad thai": "Thai",
                "burrito": "Mexican",
                "sushi": "Japanese",
                "curry": "Indian",
                "naan": "Indian",
                "tikka masala": "Indian",
                "gyro": "Greek",
                "taco": "Mexican",
                "pizza": "Italian",
                "risotto": "Italian",
                "paella": "Spanish",
                "dim sum": "Chinese",
                "pho": "Vietnamese",
                "burger": "American",
                "kimchi": "Korean"
            };
            
            const lowerMessage = message.toLowerCase();
            const foundCuisines = [];
            const confidenceScores = {};
            
            // Check for specific dishes first
            for (const [dish, cuisine] of Object.entries(dishToCuisine)) {
                if (lowerMessage.includes(dish)) {
                    if (!foundCuisines.includes(cuisine)) {
                        foundCuisines.push(cuisine);
                        confidenceScores[cuisine] = 0.85; // High confidence for specific dish match
                    }
                }
            }
            
            // Check for cuisine types and their associated foods
            for (const [cuisine, keywords] of Object.entries(cuisineTypes)) {
                // Skip if we already found this cuisine from a dish
                if (foundCuisines.includes(cuisine)) {
                    continue;
                }
                
                let confidence = 0;
                
                // Direct mention of cuisine has highest confidence
                if (lowerMessage.includes(cuisine.toLowerCase())) {
                    confidence = 0.9;
                    foundCuisines.push(cuisine);
                    confidenceScores[cuisine] = confidence;
                    continue;
                }
                
                // Check for cuisine-specific foods
                for (const keyword of keywords) {
                    if (lowerMessage.includes(keyword)) {
                        // Add to confidence for each match
                        confidence += 0.2;
                    }
                }
                
                // If we have some confidence, add it
                if (confidence > 0.3) {
                    foundCuisines.push(cuisine);
                    confidenceScores[cuisine] = Math.min(confidence, 0.8); // Cap at 0.8
                }
            }
            
            // Return cuisines with confidence scores
            if (foundCuisines.length > 0) {
                return {
                    cuisines: foundCuisines,
                    confidence: confidenceScores,
                    primaryCuisine: foundCuisines[0]
                };
            }
            
            return {
                cuisines: ["Unknown"],
                confidence: {Unknown: 0},
                primaryCuisine: "Unknown"
            };
        }

        // Helper functions
        function isCommonPhrase(text) {
            const commonPhrases = [
                "I went", "I had", "I tried", "I visited", "The place", "The restaurant",
                "You should", "This place", "Last week", "Last night", "Try the"
            ];
            return commonPhrases.includes(text);
        }
        
        function isLikelyLocation(text) {
            const commonLocations = [
                "New York", "Los Angeles", "Chicago", "San Francisco", "San Diego", 
                "Miami", "Seattle", "Boston", "Washington", "Dallas", "Houston",
                "Tokyo", "Paris", "London", "Rome", "Berlin", "Madrid", "Bangkok",
                "Beijing", "Hong Kong", "Manhattan", "Brooklyn", "Queens", "Bronx",
                "California", "Texas", "Florida", "Japan", "Italy", "France", "Spain",
                "China", "Thailand", "Germany", "England", "Mexico", "Canada",
                "Downtown", "Uptown", "Midtown", "North", "South", "East", "West"
            ];
            
            // Direct match
            if (commonLocations.includes(text)) {
                return true;
            }
            
            // Check if it ends with common location suffixes
            const locationSuffixes = ["ville", "town", "city", "burg", "berg", "borough", "shire"];
            for (const suffix of locationSuffixes) {
                if (text.toLowerCase().endsWith(suffix)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function isCommonWord(word) {
            const commonWords = [
                'the', 'and', 'but', 'for', 'nor', 'yet', 'so', 'as', 'at', 'by', 'in', 'of', 'on', 
                'to', 'up', 'it', 'is', 'are', 'was', 'were', 'this', 'that', 'they', 'their', 'just',
                'very', 'with', 'have', 'had', 'has', 'been', 'would', 'could', 'should'
            ];
            return commonWords.includes(word.toLowerCase());
        }

        // Overall extraction function
        function analyzeRestaurantRecommendation(message) {
            // First, determine if this is a restaurant recommendation
            const recommendationAnalysis = isRestaurantRecommendation(message);
            
            // Extract restaurant details regardless of recommendation status
            // This helps us catch casual mentions in mixed messages
            const nameAnalysis = extractRestaurantName(message);
            const locationAnalysis = extractLocation(message);
            const cuisineAnalysis = extractCuisineTypes(message);
            
            // Special case for casual mixed messages:
            // If we found a high-confidence restaurant name and location/cuisine,
            // even if the message doesn't seem like a recommendation, we'll still treat it as valid
            const hasHighConfidenceName = nameAnalysis.name !== "Unknown Restaurant" && nameAnalysis.confidence >= 0.7;
            const hasLocation = locationAnalysis.location !== "Unknown Location";
            const hasCuisine = cuisineAnalysis.cuisines[0] !== "Unknown";
            
            // If we have a restaurant name and either location or cuisine, consider it valid
            // even if it doesn't look like a pure recommendation
            const isCasualMention = hasHighConfidenceName && (hasLocation || hasCuisine);
            
            // Check if this is a valid restaurant mention (either formal recommendation or casual mention)
            if (!recommendationAnalysis.isRecommendation && !isCasualMention) {
                return {
                    success: false,
                    message: "This doesn't appear to be a restaurant recommendation.",
                    confidence: recommendationAnalysis.confidence,
                    score: recommendationAnalysis.score
                };
            }
            
            // Validate the extraction results
            const nameConfidence = nameAnalysis.confidence;
            
            // If we have low confidence in the restaurant name, reject it
            // unless it's a casual mention with supporting evidence
            if ((nameAnalysis.name === "Unknown Restaurant" || nameConfidence < 0.4) && !isCasualMention) {
                return {
                    success: false,
                    message: "Could not confidently identify a restaurant name.",
                    nameAnalysis,
                    locationAnalysis,
                    cuisineAnalysis,
                    recommendationScore: recommendationAnalysis.score
                };
            }
            
            // Determine overall confidence
            // For casual mentions, we'll boost the confidence if we have location and cuisine
            let overallConfidence = (nameAnalysis.confidence + 
                                  (locationAnalysis.confidence || 0) + 
                                  (cuisineAnalysis.cuisines[0] !== "Unknown" ? 0.5 : 0)) / 2.5;
            
            // Boost confidence for casual mentions with both location and cuisine
            if (isCasualMention && hasLocation && hasCuisine) {
                overallConfidence = Math.min(overallConfidence + 0.15, 0.95);
            }
            
            // Create a mock restaurant object
            const restaurant = {
                name: nameAnalysis.name,
                location: locationAnalysis.location,
                cuisine: cuisineAnalysis.cuisines,
                extractionConfidence: {
                    overall: overallConfidence,
                    name: nameAnalysis.confidence,
                    location: locationAnalysis.confidence,
                    cuisine: cuisineAnalysis.cuisines[0] !== "Unknown" ? 0.5 : 0
                },
                analysis: {
                    nameAnalysis,
                    locationAnalysis,
                    cuisineAnalysis,
                    recommendationAnalysis,
                    isCasualMention
                }
            };
            
            // Determine success message
            let successMessage = `Successfully extracted restaurant information with ${(restaurant.extractionConfidence.overall * 100).toFixed(0)}% confidence.`;
            if (isCasualMention && !recommendationAnalysis.isRecommendation) {
                successMessage = `Detected casual restaurant mention with ${(restaurant.extractionConfidence.overall * 100).toFixed(0)}% confidence.`;
            }
            
            return {
                success: true,
                restaurant: restaurant,
                message: successMessage
            };
        }

        // UI functionality
        document.getElementById('test-button').addEventListener('click', function() {
            const messageText = document.getElementById('message-text').value;
            const resultsEl = document.getElementById('results');
            const resultsContentEl = document.getElementById('results-content');
            
            // Analyze the message
            const analysis = analyzeRestaurantRecommendation(messageText);
            
            // Display results
            let resultsHTML = '';
            
            if (analysis.success) {
                resultsHTML += `<p class="success">✅ ${analysis.message}</p>`;
                resultsHTML += `<h3>Extracted Information:</h3>`;
                resultsHTML += `<p><strong>Name:</strong> ${analysis.restaurant.name} (${(analysis.restaurant.extractionConfidence.name * 100).toFixed(0)}% confidence)</p>`;
                resultsHTML += `<p><strong>Location:</strong> ${analysis.restaurant.location} (${(analysis.restaurant.extractionConfidence.location * 100).toFixed(0)}% confidence)</p>`;
                resultsHTML += `<p><strong>Cuisine:</strong> ${analysis.restaurant.cuisine.join(', ')} (${(analysis.restaurant.extractionConfidence.cuisine * 100).toFixed(0)}% confidence)</p>`;
                
                // Show detailed analysis
                resultsHTML += `<h3>Detailed Analysis:</h3>`;
                resultsHTML += `<p><strong>Recommendation Score:</strong> ${analysis.restaurant.analysis.recommendationAnalysis.score} (${analysis.restaurant.analysis.recommendationAnalysis.confidence} confidence)</p>`;
                
                // Name candidates
                resultsHTML += `<p><strong>Name Candidates:</strong></p>`;
                resultsHTML += `<pre>${analysis.restaurant.analysis.nameAnalysis.allCandidates.join('\n')}</pre>`;
                
                // Location candidates
                resultsHTML += `<p><strong>Location Candidates:</strong></p>`;
                resultsHTML += `<pre>${analysis.restaurant.analysis.locationAnalysis.allCandidates.join('\n')}</pre>`;
                
                // Original message
                resultsHTML += `<h3>Original Message:</h3>`;
                resultsHTML += `<pre>${messageText}</pre>`;
            } else {
                resultsHTML += `<p class="error">❌ ${analysis.message}</p>`;
                
                // If we have analysis details, show them
                if (analysis.nameAnalysis) {
                    resultsHTML += `<h3>Detailed Analysis:</h3>`;
                    resultsHTML += `<p><strong>Recommendation Score:</strong> ${analysis.recommendationScore}</p>`;
                    
                    // Name candidates (if any)
                    if (analysis.nameAnalysis.allCandidates.length > 0) {
                        resultsHTML += `<p><strong>Name Candidates:</strong></p>`;
                        resultsHTML += `<pre>${analysis.nameAnalysis.allCandidates.join('\n')}</pre>`;
                    }
                    
                    // Location candidates (if any)
                    if (analysis.locationAnalysis.allCandidates.length > 0) {
                        resultsHTML += `<p><strong>Location Candidates:</strong></p>`;
                        resultsHTML += `<pre>${analysis.locationAnalysis.allCandidates.join('\n')}</pre>`;
                    }
                }
                
                // Original message
                resultsHTML += `<h3>Original Message:</h3>`;
                resultsHTML += `<pre>${messageText}</pre>`;
            }
            
            resultsContentEl.innerHTML = resultsHTML;
            resultsEl.style.display = 'block';
        });
        
        // Test case buttons
        document.querySelectorAll('.test-case').forEach(button => {
            button.addEventListener('click', function() {
                document.getElementById('message-text').value = this.getAttribute('data-message');
                document.getElementById('test-button').click();
            });
        });
    </script>
</body>
</html> 